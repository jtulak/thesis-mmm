%==================================
% (c) Jan Tulak, 2017
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Results}\label{chap:results}
%----------------------------------------------------------------------

In this chapter, the results of every tool are compared and analysed. In
\Cref{tab:results:overview} is a summary of how many issues every tool
found. If not stated otherwise, the number of issues is for mkfs-specific
files, i.e., for files in {\tt mkfs/} directory.

\begin{table}[h]
\begin{tabular}{|r||r|r|r|r|r|r|}
\hline
Commit & CppCheck & Codacy & CPAChecker & Coverity & GCC & Clang \\
\hline
\hline
\multicolumn{7}{|c|}{Total issues}\\
\hline
(tag: v4.11.0-rc1) {\tt 07a3e793} & $1$ & $3$ & & $119$ & $30$ & $34$ \\
\hline
(tag: v4.7.0) {\tt d7e1f5f1} & $1$ & $4$ & & $119$ & $30$ & $28$ \\
\hline
\hline
\multicolumn{7}{|c|}{Changes}\\
\hline
{\em [Last of my set]} {\tt 2aca16d6} & 0 & 0 & & 0 & 0 & 0 \\
\hline
{\tt aa3034d4} & 0 & 0 & & $+2$/$-2$ & 0 & 0 \\
\hline
{\tt 6de2e6c0} & 0 & 0 & & $+5$ & 0 & 0 \\
\hline
{\tt ddc3b2da} & 0 & 0 & & 0 & 0 & 0\\
\hline
{\tt 06ac92fd} & 0 & 0 & & $+12$/$-3$ & $+1$ & $+1$\\
\hline
{\tt 27ae3a59} & 0 & 0 & & $+1$ & 0 & 0 \\
\hline
{\tt 3ec1956a} & 0 & 0 & & $+1$/$-3$ & 0 & 0 \\
\hline
{\tt 6c855628} & 0 & 0 & & $+2$/$-2$ & $-2$ & $-2$ \\
\hline
{\tt 627e74fd} & $-3$ & $-2$ & & 0 & $+2$ & $+2$ \\
\hline
{\tt 9090e187} & 0 & 0 & & $+2$ & 0 & 0 \\
\hline
{\tt 1974d3f1} & 0 & 0 & & 0 & $-1$ & 0 \\
\hline
{\tt 56e4d368} & 0 & 0 & & $-3$ & 0 & 0 \\
\hline
{\tt a9dad670} & 0 & 0 & & $+4$ & $-54$ & $-54$ \\
\hline
{\tt 147e0f31} & 0 & 0 & & $+3$ & 0 & 0 \\
\hline
{\tt c81c8460} & 0 & 0 & & 0 & $-50$ & $-50$ \\
\hline
{\tt a887c950} & 0 & 0 & & $+1$/$-3$ & $+13$ & $+12$ \\
\hline
{\tt 5f1a2100} & 0 & 0 & & 0 & 0 & 0 \\
\hline
{\tt ff21c709} & 0 & 0 & & 0 & $+1$ & $+1$ \\
\hline
{\em [First of my set]} {\tt 4a32b9e9} & $-1$ & $-1$ & & 0 & 0 & 0 \\
\hline
\hline
\multicolumn{7}{|c|}{Total issues} \\
\hline
{\em [Before my set]} {\tt 6aa32b47} & $5$ & $6$ & & $111$ & $121$ & $117$ \\
\hline
(4.6.0) {\tt 09033e35} & $5$ & $6$ & & $111$ & $121$ & $117$ \\
\hline
\end{tabular}
\caption{An overview of issues found by the tested tools on specific revisions
	in mkfs-only files. Coverity numbers are for aggressivness level {\em
	custom} (all checkers enabled).\newline
	\newline
	Legend: Revisions annotated with {\em total issues} shows the
	number of outstanding issues. All other revisions shows new/fixed
	issues.  $+x$ denotes amount of new issues found, $-x$ denotes number
	of issues fixed between this and the previously tested revision. A ---
	dash means that the tool was not used on this specific revision.}


\label{tab:results:overview}
\end{table}

It is apparent from the table, even on the first glance, that the tools
performance varies widely. Not only in absolute numbers of reported issues (of
some are false positives), but also in analysing specific revisions. For
example, revision {\tt a9dad670} fixed 54 issues according to GCC, but
according to Coverity, it caused 4 new and did not fix anything.

Further in the text, we have both a simple statistical analysis of what each
tool found, and a more detailed look on some specific issues and revisions,
especially where the tools have seriously different results.



%======================================================================
\section{CppCheck}\label{chap:results:cppcheck}
%----------------------------------------------------------------------
CppCheck (and Codacy, which is using it) found less issues than other
tools. When the kind of issues found is analysed, it becomes apparent that
this tool is greatly limited.

When compared with Codacy, CppCheck reports one issue twice: Checking if an
unsigned variable is less than zero. This happens on two places, but Codacy
ignores the second occurrence. On the other side, CppCheck did not find any
issue in {\tt mkfs/proto.c} file, where Codacy did.

These differences might be caused by a different configuration of CppCheck,
because we used the default configuration, but do not know what changes
Codacy did.

Despite of this, the results are very similar when compared to other tools,
so we use only CppCheck in further comparison with other tools. CppCheck is
selected because we have greater control over it, unlike cloud service Codacy.


% ------------------------------------------------
\subsection{Version 4.6.0}
An overview of issues at this revision.
\begin{table}[h]
\begin{tabular}{|l||r||r|}
\hline
& {\tt mkfs/xfs\_mkfs.c} & Whole xfsprogs \\
\hline
Issues & 5 & 460 \\
\hline
\end{tabular}
\caption{In mkfs-specific files, 1 issue was found, and 460 issues in whole
xfsprogs. From these, 100 issues were not stylistic.}
%\label{tab:results:overview}
\end{table}

The issues found in mkfs is:
\begin{enumerate}
	\item {\tt mkfs/xfs\_mkfs.c:1067}: Checking if unsigned variable 'blocksize' is less than zero.
	\item {\tt mkfs/xfs\_mkfs.c:1698}: Checking if unsigned variable
		'sectorsize' is less than zero.
	\item {\tt mkfs/xfs\_mkfs.c:1225}: Checking if unsigned variable
		'sectorsize' is less than zero.
	\item {\tt mkfs/xfs\_mkfs.c:2487}: Condition '0' is always false
	\item {\tt mkfs/xfs\_mkfs.c:2733}: The scope of the variable 'bucket' can be reduced.
\end{enumerate}

All these issues were present for multiple years. Precise dating is
difficult, however, because e.g. issue 1 is blamed to a commit 16 years
old. But at that time, the variable was signed. Thus, the issue appeared
some time later, when the specific variable was turned to unsigned, but not
every use was fully converted.

Neither of these issues is of any seriousness. Every found check of an
unsigned variable to being lower than zero is in fact a less-or-equal
check. \Cref{lst:results:sectorsize} shows the specific code for both cases
of offending sectorsize. Thus, {\tt unsigned\_variable <= 0} may be
misleading, but functionally is equivalent to {\tt unsigned\_variable ==
0}.  And the condition '0' being always false is a value intentionally
passed to a macro.

Other tools does not report this case of unsigned variable comparison,
likely because the lower-than symbol in this case does not have any effect.

\begin{lstlisting}[frame=none, basicstyle=\footnotesize\ttfamily,
language=C, numbers=none, numberstyle=\tiny\color{black},caption=
{Condition in which unsigned sectorsize is tested to be less than zero.},
label={lst:results:sectorsize}]
if (sectorsize <= 0 || !ispow2(sectorsize))
	// do something
\end{lstlisting}

% ------------------------------------------------
\subsection{Version 4a32b9e9}
This 1 issue was fixed in mkfs:
\begin{enumerate}
	\item {\tt mkfs/xfs\_mkfs.c:2487}: Condition '0' is always false
\end{enumerate}

% ------------------------------------------------
\subsection{Version 627e74fd}
These 3 issues were fixed mkfs:
\begin{enumerate}
	\item {\tt mkfs/xfs\_mkfs.c:1579}: Checking if unsigned variable 'blocksize' is less than zero.
	\item {\tt mkfs/xfs\_mkfs.c:1705}: Checking if unsigned variable
		'sectorsize' is less than zero.
	\item {\tt mkfs/xfs\_mkfs.c:2111}: Checking if unsigned variable
		'sectorsize' is less than zero.
\end{enumerate}

% ------------------------------------------------
\subsection{Version 4.11-rc1 and 4.7.0}
An overview of issues at these revisions.
\begin{table}[h]
\begin{tabular}{|l||r||r|}
\hline
& {\tt mkfs/xfs\_mkfs.c} & Whole xfsprogs \\
\hline
Issues & 1 & 440 \\
\hline
\end{tabular}
\caption{In mkfs-specific files, 1 issue was found. In whole xfsprogs, 440
issues were found, from which 100 issues were not style issues.}
%\label{tab:results:overview}
\end{table}

The issues found in mkfs is:
\begin{enumerate}
	\item {\tt mkfs/xfs\_mkfs.c:2918}: The scope of the variable 'bucket' can be reduced.
\end{enumerate}



%======================================================================
\section{Codacy}\label{chap:results:codacy}
%----------------------------------------------------------------------
Codacy shows only per-commit and total issues for a branch. That is, a
developer can view whether a specific commit fixed or caused an issue, and
can see what are the issues for the top of the repository, but checking the
complete state on a particular point in the history requires creating a new
branch, which is uncomfortable, but manageable for a private\footnote{In
the sense of being the only user, not in terms of visibility.} repository.
In a repository with many contributors it can be confusing.

Codacy provides some rating on the project's page~\cite{codacyXfsprogs},
which considers xfsprogs as a quality project (A-grade), but the weight of
this rating is unclear and rather informal. Also, it is not clear without
checking every issue, what metrics Codacy uses to asses the type, whether
it is style, error or security issue.

For comparison with other tools, see introduction of \Cref{chap:results:cppcheck}.

% ------------------------------------------------
\subsection{Version 4.6.0}\label{chap:results:codacy:4.6}

An overview of issues at this revision.
\begin{table}[h]
\begin{tabular}{|l||r|r||r|}
\hline
& {\tt mkfs/xfs\_mkfs.c} & {\tt mkfs/proto.c} & Whole xfsprogs \\
\hline
Issues & 4 & 2 & 839 \\
\hline
\end{tabular}
\caption{In mkfs-specific files, 6 issues were found. Whole
xfsprogs had 839 issues, from which 809 were code style issue and 30 were
potential errors.}
%\label{tab:results:overview}
\end{table}

The issues found in mkfs are:
\begin{enumerate}
	\item {\tt mkfs/xfs\_mkfs.c:1067}: Checking if unsigned variable 'blocksize' is less than zero.
	\item {\tt mkfs/xfs\_mkfs.c:1225}: Checking if unsigned variable 'sectorsize' is less than zero.
	\item {\tt mkfs/xfs\_mkfs.c:2487}: Condition '0' is always false
	\item {\tt mkfs/xfs\_mkfs.c:2733}: The scope of the variable 'bucket' can be reduced.
	\item {\tt mkfs/proto.c:49}: The function 'setup\_proto' is never used.
	\item {\tt mkfs/proto.c:601}: The function 'parse\_proto' is never used.
\end{enumerate}

The only two issues found here that CppCheck did not reported are the two
unused functions. However, these functions are used in {\tt
mkfs/xfs\_mkfs.c} file, thus they are false positives. Also, CppCheck found
two places on which {\tt sectorize} is checked to be less than zero, but
Codacy reports it only once. Curiously, the same issue appears on two
places not far away, and in both cases, it is in this exact condition as
can be seen on \Cref{lst:results:sectorsize} in
\Cref{chap:results:cppcheck}, just inside of different blocks, but still in
the same function and path to both places is possible.

Why Codacy does report only one of those issues is unclear.



% ------------------------------------------------
\subsection{Revision 627e74fd}
Fixed 2 issues in {\tt mkfs/xfs\_mkfs.c}:

\begin{enumerate}
	\item {\tt mkfs/xfs\_mkfs.c:1579}: Checking if unsigned variable
		'blocksize' is less than zero.
	\item {\tt mkfs/xfs\_mkfs.c:1705}: Checking if unsigned variable
		'sectorsize' is less than zero.
\end{enumerate}

% ------------------------------------------------
\subsection{Version 4.7.0}
An overview of issues at this revision.
\begin{table}[h]
\begin{tabular}{|l||r|r|r||r|}
\hline
& {\tt mkfs/xfs\_mkfs.c} & {\tt mkfs/maxtrres.c} & {\tt mkfs/proto.c} & Whole xfsprogs \\
\hline
Issues & 1 & 1 & 2 & 749 \\
\hline
\end{tabular}
\caption{In mkfs-specific files, 4 issues were found. Whole
xfsprogs had 749 issues, from which 719 were code style issue and 30 were
potential errors.}
%\label{tab:results:overview}
\end{table}

The issues found in mkfs are:
\begin{enumerate}
	\item {\tt mkfs/xfs\_mkfs.c:2918}: The scope of the variable {\tt
		bucket} can be reduced.
	\item {\tt mkfs/maxtrres.c:31}: The function {\tt max\_trans\_res}
		is never used.
	\item {\tt mkfs/proto.c:49}: The function {\tt setup\_proto} is
		never used.
	\item {\tt mkfs/proto.c:601}: The function {\tt parse\_proto} is
		never used.
\end{enumerate}

Also in this case, the supposedly unused function {\tt max\_trans\_res} is
in fact used in another file.

% ------------------------------------------------
\subsection{Version 4.11-rc1}
An overview of issues at this revision.
\begin{table}[h]
\begin{tabular}{|l||r|r||r|}
\hline
& {\tt mkfs/xfs\_mkfs.c} & {\tt mkfs/proto.c} & Whole xfsprogs \\
\hline
Issues & 1 & 2 & 937 \\
\hline
\end{tabular}
\caption{In mkfs-specific files, 3 issues were found. Whole
xfsprogs had 937 issues, from which 900 were code style issue, 36 were
potential errors and 1 was a security issue.}
%\label{tab:results:overview}
\end{table}

The issues found in mkfs are:
\begin{enumerate}
	\item {\tt mkfs/xfs\_mkfs.c:2918}: The scope of the variable
		'bucket' can be reduced.
	\item {\tt mkfs/proto.c:49}: The function 'setup\_proto' is never
		used.
	\item {\tt mkfs/proto.c:601}: The function 'parse\_proto' is never
		used.
\end{enumerate}

%======================================================================
\section{GCC}\label{chap:results:gcc}
%----------------------------------------------------------------------
GCC and Clang are very similar in what they found, with GCC finding few
more issues. In this section we describe some of the notable differences.

% ------------------------------------------------
\subsection{Version 4.6.0}\label{chap:results:gcc:4.6}

An overview of issues at this revision.
\begin{table}[h]
\begin{tabular}{|l||r|r||r|}
\hline
& {\tt mkfs/xfs\_mkfs.c} & {\tt mkfs/proto.c} & Whole xfsprogs \\
\hline
Issues & 119 & 2 & 2013 \\
\hline
\end{tabular}
\caption{In mkfs-specific files, 121 issues were found. Whole
xfsprogs had 2013 issues.}
%\label{tab:results:overview}
\end{table}

The issues are not listed here due to their numbers, but the reader can
find them on an attached optical disc, or replicate them using the tools
attached to this work. The only mention-worthy issues as the two found in
{\tt proto.c} file, because of comparison with Codacy.

As is shown in \Cref{chap:results:codacy:4.6}, Codacy found two issues in
this file too. Curiously, Codacy found two unused functions, while GCC
found these issues:
\begin{enumerate}
	\item {\tt mkfs/proto.c:270}: comparison between signed and unsigned integer expressions
	\item {\tt mkfs/proto.c:332}: unused parameter 'mp'
\end{enumerate}

These issues are not in the two functions found by Codacy, however, the are
inside of functions called from the ones found by Codacy. It is possible,
that they were not reported because of this, but given that the mentioned
Codacy issues are false positives and that Codacy did not found many other
issues, it is likely that Codacy simply did not noticed them, but GCC did.

% ------------------------------------------------
\subsection{Revision a887c950}\label{chap:results:gcc:a887c950}
Added 13 issues in {\tt mkfs/xfs\_mkfs.c}. These 13 issues are only of two
kinds:

\begin{enumerate}
	\item {\tt mkfs/xfs\_mkfs.c:1487}: comparison is always false due
		to limited range of data type
	\item {\tt mkfs/xfs\_mkfs.c} {\em multiple occurencies}: passing
		argument 2 of 'illegal' discards 'const' qualifier from
		pointer target type
\end{enumerate}

When compared with Clang, the obvious difference is the comparison issue.
The offending line is shown on \Cref{lst:results:logagnoComparison}. Closer
look on this line reveals that there is an explicit type casting. The new
type is a signed integer. However, the variable {\tt logagno} is declared
with type {\tt xfs\_agnumber\_t} and this type is declared as an alias to
{\tt \_\_uint32\_t} in file {\tt libxfs/xfs\_types.h}.

According to standard of C language, the type casting has a precedence over
comparison~\cite[A.2.1]{ISO9899}, so Clang, when evaluating this line, sees
an integer. That is technically correct, but in a wider context, it is also
clear that the possible values are still limited by the original type, and
so this comparison will be always false.  Which is what GCC noticed and
also correctly reported. No other tool reported this issue.

\TODO{Will CPA report this once it is working?}

\begin{lstlisting}[frame=none, basicstyle=\footnotesize\ttfamily,
language=C, numbers=none, numberstyle=\tiny\color{black},caption=
{Line on which GCC found the comparison issue.},
label={lst:results:logagnoComparison}]
if ((__int64_t)logagno < 0)
	// do something
\end{lstlisting}

The other issues are similar to what Clang found, but appears to suffer the
unstability in parsing mentioned in \Cref{chap:techniques:processing}.
All these issues are caused by passing a constant string to a
function which does not has the {\tt const} keyword for an argument: {\tt
illegal(value, "b log");}. The file {\tt xfs\_mkfs.c} contains 44 such
calls, but only some of them were added in this revision. Thus, we correctly
detected these issues, but some of the line numbers we see had this issue
before. If we would want to see exactly which lines were added, the easiest way
is to look to look on changes in this specific commit.


% ------------------------------------------------
\subsection{Revision 1974d3f1}
Fixed 1 issue in {\tt mkfs/xfs\_mkfs.c}, which was introduced and decribed in revision a887c950, \Cref{chap:results:gcc:a887c950}.

\begin{enumerate}
	\item {\tt mkfs/xfs\_mkfs.c:1830}: comparison is always false due
		to limited range of data type
\end{enumerate}

% ------------------------------------------------
\subsection{Version 4.7.0}\label{chap:results:gcc:4.7}

An overview of issues at this revision.
\begin{table}[h]
\begin{tabular}{|l||r|r||r|}
\hline
& {\tt mkfs/xfs\_mkfs.c} & {\tt mkfs/proto.c} & Whole xfsprogs \\
\hline
Issues & 28 & 2 & 2013 \\
\hline
\end{tabular}
\caption{In mkfs-specific files, 30 issues were found. Whole
xfsprogs had 1923 issues.}
%\label{tab:results:overview}
\end{table}

While in count of issues, there is only a small difference between GCC and
Clang, a closer look on the found issues reveals more changes. As can be seen
in \Cref{chap:results:clang:4.7}, Clang found three more issues in file {\tt
mkfs/proto.c}.

Almost all issues found in {\tt mkfs/xfs\_mkfs.c} are about comparison, with
only two exceptions, points 2 and 3:
\begin{enumerate}
	\item {\tt mkfs/xfs\_mkfs.c} {\em multiple occurences}: comparison
		between signed and unsigned integer expressions
	\item {\tt mkfs/xfs\_mkfs.c:728}: unused parameter 'lsectsz'
	\item {\tt mkfs/xfs\_mkfs.c:1896}: passing argument 2 of 'unknown'
		discards 'const' qualifier from pointer target type
\end{enumerate}


%======================================================================
\section{Clang}\label{chap:results:clang}
%----------------------------------------------------------------------
The results of Clang are very similar to GCC, although there are few issues
which Clang did not found.

% ------------------------------------------------
\subsection{Version 4.6.0}\label{chap:results:clang:4.6}

An overview of issues at this revision.
\begin{table}[h]
\begin{tabular}{|l||r|r||r|}
\hline
& {\tt mkfs/xfs\_mkfs.c} & {\tt mkfs/proto.c} & Whole xfsprogs \\
\hline
Issues & 113 & 4 & 2597 \\
\hline
\end{tabular}
\caption{In mkfs-specific files, 117 issues were found. Whole
xfsprogs had 2597 issues.}
%\label{tab:results:overview}
\end{table}

In addition to the two issues found by GCC in {\tt mkfs/xfs\_mkfs.c} in \Cref{chap:results:gcc:4.6}, Clang found two other issues (both of the same kind):
\begin{enumerate}
	\item {\tt mkfs/proto.c:270}: comparison between signed and unsigned integer expressions
	\item {\tt mkfs/proto.c:332}: unused parameter 'mp'
	\item {\tt mkfs/proto.c:130}: missing field 'tr\_logcount' initializer
	\item {\tt mkfs/proto.c:631}: missing field 'tr\_logcount' initializer
\end{enumerate}

These two new issues, complaining about a missing field, are probably false
positives, because on these lines, a structure with all members zeroed is
created, as can be seen in \Cref{lst:results:zeroedStruct}.


\begin{lstlisting}[frame=none, basicstyle=\footnotesize\ttfamily,
language=C, numbers=none, numberstyle=\tiny\color{black},caption=
{One of the two lines on which Clang reports a missing field in structure
initialization.},
label={lst:results:zeroedStruct}]
struct xfs_trans_res    tres = {0};
\end{lstlisting}

% ------------------------------------------------
\subsection{Revision a887c950}
Added 12 issues in {\tt mkfs/xfs\_mkfs.c}. These 12 issues are only of one
kind, similar to what GCC found for this revision.

\begin{enumerate}
	\item {\tt mkfs/xfs\_mkfs.c} {\em multiple occurencies}: passing
		'const char [7]' to parameter of type 'char *' discards
		qualifiers
\end{enumerate}

% ------------------------------------------------
\subsection{Version 4.7.0}\label{chap:results:clang:4.7}

An overview of issues at this revision.
\begin{table}[h]
\begin{tabular}{|l||r|r||r|}
\hline
& {\tt mkfs/xfs\_mkfs.c} & {\tt mkfs/proto.c} & Whole xfsprogs \\
\hline
Issues & 23 & 5 & 2511 \\
\hline
\end{tabular}
\caption{In mkfs-specific files, 28 issues were found. Whole
xfsprogs had 2511 issues.}
%\label{tab:results:overview}
\end{table}

Clang found three more issues in this revision than GCC did. Two of them
already appeared in description of revision 4.6 in
\Cref{chap:results:clang:4.6}, the third issue is of the same kind and was
introduced by some other patch other than which are part of this work.

Most issues are about comparison, with multiple versions of wording, because
where GCC uses only one universal message, Clang uses a template into which it
substitues specific types, as can be seen in the list of reported issues:
\begin{enumerate}
	\item {\tt mkfs/xfs\_mkfs.c} {\em multiple occurences with varying
		types}: comparison of integers of different signs: 'unsigned
		int' and 'int'
	\item {\tt mkfs/xfs\_mkfs.c:3129}: missing field 'tr\_logcount'
		initializer
	\item {\tt mkfs/xfs\_mkfs.c} {\em multiple occurences}: cast from 'char *' to
		'xfs\_alloc\_rec\_t *' (aka 'struct xfs\_alloc\_rec *')
		increases required alignment from 1 to 4
	\item {\tt mkfs/xfs\_mkfs.c:1896}: passing 'const char [1]' to
		parameter of type 'char *' discards qualifiers
\end{enumerate}


%======================================================================
\section{Coverity}\label{chap:results:coverity}
%----------------------------------------------------------------------

Coverity, when run manually in the docker container, found the highest number
of issues from all the tools. The online version found 9 issues in
mkfs-specific files on a recent (4.11) version~\cite{CoverityXfsprogs},
compared to 97 found on a manual run with a high level of aggressivness. What
effect the aggressivness level has can be seen on
\Cref{tab:results:coverity:levels}.  It is apparent that the online service
uses a special configuration, but we were not able to identify specifics.

\begin{table}[h]
\begin{tabular}{|l||r||r|r|r|r|}
\hline
& Coverity online & low & medium & high & custom \\
\hline
Issues reported & 9 & 0 & 36 & 97 & 119 \\
\hline
\end{tabular}
\caption{Comparison of issues found by Coverity online service and Coverity run
locally with different levels of aggressivness. Numbers are for mkfs-specific
files. Locally tested revision is {\tt 07a3e793} (v4.11.0-rc1), the online
service tested revision {\tt ge116c5c} (v4.11.0-rc2).}
\label{tab:results:coverity:levels}
\end{table}

In most of this section, we focus on results gained from the custom (highest)
level. The online service is briefly described and some interesting statistics
comparing xfsprogs with other open-source projects are provided only in
\Cref{chap:results:coverity:online}.

The reasons for selecting custom level aggressivness as the level on which our
analysis focusses is that for other tools we used the strictest settings
available, thus, analysing relaxed approach on any other level is not
comparable with other tools.

% ------------------------------------------------
\subsection{Online Service}\label{chap:results:coverity:online}

The online service available at
\url{https://scan.coverity.com/projects/xfsprogs} provides various statistics
in addition to reported issues.

%======================================================================
\section{CPAChecker}\label{chap:results:cpachecker}
%----------------------------------------------------------------------

%======================================================================
\section{Summary}\label{chap:results:summary}
%----------------------------------------------------------------------

